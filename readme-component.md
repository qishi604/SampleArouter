# 组件化方案介绍

![](img/component.png)

## 一. 什么是组件化

模块化是一种指导理念，其核心思想就是分而治之，解耦分层。将项目拆分成各个组件(功能模块)，组件相互独立，可以并行开发。
一套完整的插件化或组件化都能够实现单独调试、集成编译、数据传输、UI 跳转、生命周期和代码边界这六大功能。

## 二. 为什么要使用组件化

项目发展到一定程度，代码越来越臃肿，编译一次需要很长时间。
由于业务复杂，代码耦合严重，每个人在写新需求时都有严重的代码包袱，花费在熟悉老代码的时间
甚至大于新需求的开发时间。并且每个改动都需要进行大范围的回归测试。这严重影响开发效率，这时候就必须进行模块化的拆分。

## 三. 如何实现组件化

要实现组件化，主要考虑一下几个方面：

- 代码解耦。如何将一个庞大的工程拆分成有机的整体？

- 组件单独调试。每个组件都是一个完整的整体，如何让其单独运行和调试呢？

- 数据传递。因为每个组件都会给其他组件提供的服务，那么主项目（Host）与组件、组件与组件之间如何传递数据？

- UI跳转。UI跳转可以认为是一种特殊的数据传递

- 组件的生命周期。我们的目标是可以做到对组件可以按需、动态的使用，因此就会涉及到组件加载、卸载和降维的生命周期。

- 集成调试。在开发阶段如何做到按需的编译组件？一次调试中可能只有一两个组件参与集成，这样编译的时间就会大大降低，提高开发效率。

- 代码隔离。如何从根本上避免组件之间的直接引用呢？只有做到这一点才是彻底的组件化。

### 1. 代码解耦

Android Studio 工程支持多 module。我们对两种 module 进行区分

- 基础库 library，这些代码被其他组件直接引用。如网路库、图片加载库、常用工具类等

- Component（组件），这种 module 是一个完整的功能模块。比如 IM模块、用户模块等

将 library 称之为依赖库，Component 称为组件，而负责拼装这些组件的形成完整 app 的 module，称之为主项目或主 module 或 app module

### 2. 组件单独调试

要实现单独调试需要对组件 module 做一些修改：

1. 修改组件的 `build.gradle` 把 `apply plugin: 'com.android.library'` 换成 `apply plugin: 'com.android.application'`

2. 新建一个 AndroidManifest，增加入口 activity

3. 为了避免组件资源冲突，在组件的 `build.gradle`中增加 `resourcePrefix xxx_`，从而固定每个组件的资源前缀。 

### 3. 数据传递

主项目和组件、组件与组件之间不能直接使用类的相互引用来进行数据交互。那么如何做到这个隔离呢？
可以采用接口+实现的结构。每个组件声明自己提供的服务Service，这些Service都是一些抽象类或者接口，
组件负责将这些Service实现并注册到一个统一的路由Router中去。要使用某个组件的功能，只需向Router
请求这个Service的实现，具体的实现细节我们全然不关心，只要能返回我们需要的结果就可以了。

### 4. UI跳转

UI的跳转也是组件提供的一种特殊的服务，可以归属到上面的数据传递中去。具体实现是通过在每个Activity上添加注解，
然后通过apt形成具体的逻辑代码。

### 5. 组件的生命周期

要动态的管理组件，需要给每个组件添加几个生命周期状态：加载、卸载和降维。

1. 加载：组件负责将自己的服务实现注册到 Router 中

2. 卸载：组件将自己的服务从 Router 中取消注册。

3. 降维：比如一个组件出现了问题，我们需要把这个组件改成一个 h5。降维一般需要后台配置才生效。

### 6. 集成调试

在开发后期我们需要把几个组件机集成到一个app里面去验证。由于我们上面的机制保证了组件之间的隔离，
所以我们可以任意选择几个组件参与集成。这种按需索取的加载机制可以保证在集成调试中有很大的灵活性，
并且可以加大的加快编译速度。

### 7. 代码隔离

我们希望只在assembleDebug或者assembleRelease的时候把aar引入进来，而在开发阶段，所有组件
都是看不到的，这样就从根本上杜绝了引用实现类的问题。代码隔离可以通过编写 gradle 插件来实现。



